
# Extra (advanced) techniques

## 'Flipping' axes

One neat trick when using boxplots is to 'flip' the axes, so the boxes are horizontal. This
can save space and make the graph easier to read when there are many categories.

E.g. compare this:

```{r}
asia <- development %>%
  filter(continent=="Asia")

asia %>%
  ggplot(aes(country, life_expectancy)) +
  geom_boxplot()
```

With this:

```{r}
asia %>%
  ggplot(aes(country, life_expectancy)) +
  geom_boxplot() +
  coord_flip()
```


All we had to do was add `+ coord_flip()` to the end of our code. This is short for 'flip coordinates' (i.e. swap
the x and y axes).


## Get things in order

Another useful technique is to sort the boxes by their average, or some other value.

```{r, eval=F}
asia %>%
  ggplot(aes(fct_reorder(country, life_expectancy, median, .desc=TRUE), life_expectancy)) +
  geom_boxplot() +
  coord_flip()
```


```{r, echo=F}
# hidden because xlab/ylab not introduced yet
asia %>%
  ggplot(aes(fct_reorder(country, life_expectancy, median, .desc=TRUE), life_expectancy)) +
  geom_boxplot() +
  coord_flip() + xlab("") + ylab("Life expectancy")
```


Here we changed `country` to read `fct_reorder(country, life_expectancy, median)`. Let's unpack that.
Taking each part in order, it means:

- reorder a factor (i.e. change the ordering of the categories)
- we are going to reorder the `country` column
- reorder the categories using values in the `life_expectancy` column
- use the `median` to decide the sorting order
- `.desc=TRUE` means use a *descending* sort (i.e. we do a reverse sort on the median)


The result is a plot where all the countries are arranged in descending order of their median life expectancy.


## Adding labels

If we want to make the x and y labels on our plot nicer, we can use `+ xlab("label")` and  `+ ylab("label")`.

For example:

```{r}
fuel %>%
  ggplot(aes(factor(gear), mpg)) +
  geom_boxplot() +
  xlab("Number of gears") + ylab("Fuel economy (mpg)")
```



:::{.exercise}

## (Advanced) Extension Exercise: 1

This plot of the American countries is OK, but it's hard to read the labels:

```{r, echo=F}
development %>%
  filter(continent=="Americas") %>%
  ggplot(aes(country, life_expectancy)) +
  geom_boxplot()
```

Can you convert it to look more like this?


```{r, echo=F}
development %>%
  filter(continent=="Americas") %>%
  ggplot(aes(fct_reorder(country, life_expectancy, .desc=TRUE), life_expectancy)) +
  geom_boxplot() +
  coord_flip() + xlab("") + ylab("Life expectancy")
```


Reflection: Imagine someone using the graph for various different purposes.
Is it always helpful to sort the countries in order of life expectancy? How should we
decide when and how to sort the data?
:::




















# Introducing markdown {#markdown}

```{r, echo=F}
identifier <- "introducing-markdown"
ytidentifier <- "yt-embed"
# makermds(identifier)
```

```{r child = '_content/_video_tabs.rmd'}

```

:::{.exercise}

**Exercise 11**

1. For each of the chunks you wrote for Exercises 4-7:
   i) Add the section name as a level 2 heading.
   i) Add the exercise number as a level 3 heading.
   i) Add the instructions as a numbered list (or as plain text if there's only one instruction).
2. Use the outline feature to explore the document.
3. Knit the document.
   :::

STUFF FROM SESSION 1

We show the benefit of jitter somewhere here now

<!-- he points on the scatter plot are 'jittered' to avoid -->
<!-- overplotting, making the output easier to read. -->

```{r}
mpg %>%
  ggplot(aes(cty, hwy)) + geom_point()

mpg %>%
  ggplot(aes(cty, hwy)) + geom_jitter()
```

`r hide('Video script')`
A problem with this plot is that there are many cars with the same number of cylinders. Another way of saying this is
that `cyl` has been plotted using an 'integer (whole number) scale'. Consequently, many of the points are plotted on top
of each other, making the values hard to see. The overplotting issue is easily solved by replacing `geom_point()` with
`geom_jitter()`, which spreads the points out where cars have the same number of cylinders.
`r unhide()`

ALSO SHOW COLOR SCALE PROBLEM (REPEATS FROM PREV SESSION)

```{r}
mtcars %>%
  ggplot(aes(wt, mpg, colour = cyl)) +
  geom_point()
```

The number of cylinders are plotted in continuous shades of blue. This isn't terrible, but it would be clearer if each
number of cylinders had its own colour. This is the same problem we had with some of the other `mtcars` variables. They
have type `dbl`, when they are actually factors. We can use `factor` to fix the colours in the same way we fixed the
x-axis:

```{r}
mtcars %>%
  ggplot(aes(wt, mpg, color = factor(cyl))) +
  geom_point()
```

In this plot it's easier to see that cars with more cylinders tend to be heavier, and have worse fuel consumption.

# Dividing up graphs with facets {#facets}

<!-- TODO CHANGE THIS TO EXTEND PREVIOUS EXERCISES IN THIS WORKSHEET -->

In our previous plots we only showed the difference between cars of 4, 6 and 8 cylinders. We can break the plot down
into multiple panels using '**facets**':

```{r}
mtcars %>%
  ggplot(aes(factor(cyl), mpg)) +
  geom_boxplot() +
  facet_wrap(vars(am))   # note to paul... use vars here to avoid quoting of variable names which is confusing/inconsistent with other use
```

# Extension techniques

### Sorting

Sorting is often useful for this sort of question.

We can sort data in R using the `arrange()` function.

For example:

Q: Which countries had the lowest life expectancy in the 20th century?

```{r}
development %>%
  # sort the data by life expectancy
  arrange(life_expectancy) %>%
  head(3)  # show only the first few rows
```

If you want to sort in the reverse order, put a hyphen in front of column you are sorting.
This means _sort in reverse order_.

```{r}
development %>%
  # to sort the data by life expectancy in descending order add a hyphen
  arrange(-life_expectancy) %>%
  head(3)  # show only the first few rows
```

### Combining multiple operations in a pipeline

We can combine multiple functions to answer more detailed questions.

Q: Which countries had the lowest life expectancy _in 1992_?

```{r}
development %>%
  filter(year==1992) %>%
  arrange(life_expectancy) %>%
  head(3)
```

We can also combine filtering, _grouping_ and summarising in a single pipeline.

Q: What was the average life expectancy in 1992 on each continent?

```{r}
development %>%
  group_by(continent) %>%
  filter(year==1992) %>%
  summarise(mean(life_expectancy))
```

### Summary of descriptions

---

| Description of   | Statistic    | Plot                             | R function                                      |
| ---------------- | ------------ | -------------------------------- | ----------------------------------------------- |
| Central tendency | Mean, median | Boxplot                          | `sumarise()`, `geom_boxplot()`                  |
| Distribution     | SD, IQR      | Density plot; boxplot            | `summarise()`, geom_boxplot()`,`geom_density()` |
| Relationship     | Correlation  | Scatterplot (plus smoothed line) | `cor()`, `geom_point()`, `geom_smooth()`        |

---

A nice addition to that technique --- and one which emphasises the idea of relationships --- is the **smoothed line plot**.

### Smoothed line plots

If we plot the relationship between engine size and fuel economy in the `fuel` dataset we can see the
relationship between these variables:

```{r}
fuel %>%
  ggplot(aes(engine_size, mpg)) +
  geom_point()
```

It's fairly obvious that there is a relationship, but it's not a straight-line.
For small engined cars there is a strong negative relationship. But once you get above a
certain engine size this is less pronounced.

We can accentuate this pattern, and make the relationship between variables even clearer,
by **adding another layer** to our plot:

```{r, message=FALSE}
fuel %>%
  ggplot(aes(engine_size, mpg)) +
  geom_point() +
  geom_smooth()
```

The only addition to the previous plot is the code: `+ geom_smooth()`

This adds a smoothed line to the scatterplot. The blue line traces the _local average_ of the
value of MPG. That is, it represents what we might expect MPG to be, for any given engine size.

It's good to show both the raw datapoints AND the smoothed line because we see both the 'big picture'
relationship and any deviations from the general trend in a single plot.

Some people would say we've increased the _information density_ by adding the extra layer.

:::{.exercise}

Reproduce this table using the `earnings` data in the `psydata` package:

```{r, echo=F}
earnings %>%
  group_by(Gender=gender, `Native speaker`=native) %>%
  summarise(Income=mean(income)) %>%
  pander("Income by gender and language")
```

:::

:::{r}

Reproduce the numbers in this table, and the boxplot, using the `fuel` data:

```{r, echo=F}
df1 <- fuel %>%
  mutate(Transmission = factor(automatic, levels = c(F,T), labels=c("Manual", "Automatic"))) %>%
  rename(Weight=weight)

df1 %>%
  group_by(Transmission) %>%
  summarise(`Median weight` = median(Weight)) %>%
  pander(caption="Car weights by type of transmission")


df1 %>%
  ggplot(aes(Transmission, Weight)) +
  geom_boxplot()
```

:::

- What is the difference between `geom_jitter()` and `geom_point()`?
- Why is `geom_jitter` useful sometimes?

Each column in a dataset has an associated type. The second column of the `glimpse` output shows you the type of each column. This dataset includes columns with two types:

- `dbl` is short for 'double-precision number', a number with one or more decimal places
- `chr` — short for 'character', a variable which contains text (e.g. an email address)

Other types include:

- `fct` is short for 'factor', a categorical variable (e.g. a specific response to a multiple-choice question)
- `int` is short for 'integer', a variable which contains whole numbers (e.g. a participant id number), and
- `ord` — short for 'ordered'; a variant of _fct_ where the categories have a particular order (e.g. responses like 'Wost' < 'Better' < 'Best')

The importance of knowing the type associated with a column will become clear in a later session.

The [World Happiness Report](https://www.kaggle.com/ajaypalsinghlo/world-happiness-report-2021) is a survey of the state
of global happiness.

# Sorting data using `arrange()` {#arrange}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- The `arrange()` function sorts rows in a dataset.
- Give `arrange()` a single column name to sort data in ascending order.
- To sort in descending order, put a `-` before the column name.
- Use commas between column names to sort by more than once column at once

### Code examples

```{r}
# sort by carat in ascending order
diamonds %>%
  arrange(carat) %>%
  head(3)

# sort by carat in descending order (spot the minus sign in front of 'caret')
diamonds %>%
  arrange(-carat) %>%
  head(3)

# sort by price (descending) within carat (ascending)
diamonds %>%
  arrange(carat, -price)
```

`r hide('Show full video transcript and code')`

TODO ADD PREAMBLE / RATIONALE FOR THIS
SORTING IS A WAY TO GET MIN/MAX and INSPECT IN A TABLE

Sort by carat in ascending order

```{r}
diamonds %>%
  arrange(carat) %>%
  head(3)
```

Sort by carat in descending order

```{r}
diamonds %>%
  arrange(-carat) %>%
  head(3)
```

Sort by price (descending) within carat (ascending)

```{r}
diamonds %>%
  arrange(carat, -price)
```

`r unhide()`

:::{.exercise}
**Exercise 9**

1. Sort the `diamonds` dataset by ascending price.
1. Show only the first five rows of the results.

Your answer should look like this:

```{r, echo=FALSE}
diamonds %>%
  arrange(price) %>%
  head(5)
```

:::

:::{.exercise}

**Exercise 10**

How big is the largest diamond in the `diamonds` dataset? `r fitb('5.01')` carats.

What was the cut of the three largest diamonds in that dataset? `r fitb('Fair')`.

:::

# Combine `filter()` with `arrange()` {#filterarrange}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- Pipelines combine functions to answer specific questions.
- A good example of this is combining `filter()` and `arrange()`.

### Code examples

```{r}
# show which years Kenyans had their lowest life expectancy
gapminder %>%
  filter(country == "Kenya") %>%
  arrange(lifeExp) %>%
  head(6)

# show which year Kenyans with their life expectancy (just add '-')
gapminder %>%
  filter(country == "Kenya") %>%
  arrange(-lifeExp) %>%
  head(6)
```

`r hide('Show full video transcript and code')`
What was the year Kenyans had the lowest life exp:

```{r}
gapminder %>%
  filter(country == "Kenya") %>%
  arrange(lifeExp) %>%
  head(6)
```

What was the highest year? All that changes is the minus sign (reverse sorting)

```{r}
gapminder %>%
  filter(country == "Kenya") %>%
  arrange(-lifeExp) %>%
  head(6)
```

`r unhide()`

:::{.exercise}

**Exercise 11**

1. Sort all Asian countries in the `gapminder` dataset in ascending population order.
1. Show only the first 10 rows.

Your results should look like this:

```{r, echo=FALSE}
gapminder::gapminder %>%
  filter(continent == "Asia") %>%
  arrange(pop) %>%
  head(10)
```

**Exercise 12**

Use `filter()`, `arrange()` and `head()` to answer the following questions:

The European country with the highest life expectancy is `r fitb('Iceland')`.

The European country with the fifth largest population was recorded in which year? `r fitb('2007')`.
:::

PAUL - I'M WORRIED WEAKER STUDENTS WON'T GET THIS FAR.

PERHAPS WE SHOULD PUSH SUMMARISE INTO SESSION 3? I CERTAINLY THINK THIS IS TRUE FOR GROUP-BY

WE CAN MOTIVATE THIS BY FINDING LONG FORM DATA WE WANT TO SUMMARISE THEN RUN A T TEST ON.

CAN YOU HAVE A THINK ABOUT HOW LONG EACH OF THE VIDEOS MIGHT RUN FOR? IF STUDENTS WATCHED ALL OF THEM WOULD IT TAKE > 1 HOUR? I THINK WE SHOULD PERHAPS AIM FOR VIDEOS TOTALLING <40 MINS, THEN EXPECT EXERCISES TO TAKE 40 MINS....
I WILL HAVE ANOTHER READ THROUGH TOO

ALTERNATIVELY, WE CAN SHOW THIS HERE AND THEN REPEAT AGAIN IN SESSION 3 TO DO THE T TEST... THAT WOULD ALSO BE GOOD

The last two exercises are like the end of level "boss characters" in a computer game. To beat them, you need to select
and combine skills you've learnt so far.

## Extension exercise 1

```{r, eval=FALSE, echo=FALSE}
gapminder::gapminder %>%
  filter(year == 1952) %>%
  arrange(-lifeExp) %>%
  head(1)
```

The country with the highest life expectancy in 1952 was `r fitb('Norway')`. (Hint: use `arrange()`, `filter()` and
`head()` with the `gapminder` dataset.)

## Extension exercise 2

```{r, echo=FALSE, eval=FALSE}
gapminder::gapminder %>%
  group_by(continent) %>%
  filter(year == "1987") %>%
  summarise(average_gdp = mean(gdpPercap)) %>%
  arrange(-average_gdp)
```

The continent with the highest mean per capita GDP in 1987 was `r fitb('Oceania')`. (Hint: use `filter()`, `arrange()`,
`group_by()`, and `summarise()`.)

## Extension exercise 4

```{r, echo=FALSE, eval=FALSE}
gapminder %>%
  filter(continent == "Africa") %>%
  filter(year < "2000") %>%
  arrange(-pop, lifeExp)
```

Before the year 2000, the African country with the largest population and the lowest life expectancy was
`r fitb('Nigeria')`.

## Extension exercise 5

Make a table which shows the average life expectancy for each continent, sorted from highest to lowest. It should look like this:

```{r, echo=FALSE}
gapminder %>%
  group_by(continent) %>%
  summarise(life_expectancy = mean(lifeExp)) %>%
  arrange(-life_expectancy)
```

#### SORT AND ARRANGE CHECK YOUR KNOWLEDGE QUESTIONS

1. How would you sort a `data.frame` by a numeric column in descending order? <!-- TODO: too easy? -->
1. How would you select rows from a column which match a word, and then sort those rows in ascending order by a numeric column?

Some martial arts have a concept called 'Mushin'. A literal translation of this is 'mind without mind'. It denotes a state of mind achieved when free from thoughts of anger, fear, or ego, during combat or in everyday life. To achieve mushin takes **repeated practice** and complete familiarity with the technique required to act, so that technical details can fade into the background.

We think there is an analogy to learning R here:

- If you are anxious, stressed or avoidant you will be distracted and find it harder to learn.
- Getting confident with the basics makes more complex techniques possible.

This session is about building skills and mastering core techniques. We will use these skills throughout the course. If
some parts are already familiar to you, that's fine. If it is all new, be sure to complete all the exercises/practice
problems.

We can use simple facts or descriptions of the world to answer questions based on data we have collected. For example:

- What is the highest life expectancy in the world? or
- How many errors did participants make on a task, on average?

We have already seen techniques like `filter`, `group_by` and `summarise` which can help answer these sorts of question, by summarising raw data.

For example, given questions like this we can find answers in the data:

_Q: What is the average life expectancy across all countries in the `development` data?_

```{r}
library(psydata)

development %>%
summarise(mean(life_expectancy))
```

_Q: Which group lost most weight in the FIT trials_?

```{r}
funimagery %>%
  group_by(intervention) %>%
  summarise(mean(weight_lost_end_trt))
```

### Describing differences

### Describing distributions

Other descriptive statistics can be useful too — for example to describe how widely-spread the data are
around the mean or median.

We already saw the Interquartile Range and the Standard Deviation in the previous session. The IQR is visible on box plots and describes the range in which 50% of all the observations fall.

So if we look at a boxplot of the `funimagery` data for weight at baseline, the box represents the
area in which half of the patients fell. So, around 50% of patients had a weight between 80kg and 100kg at
baseline:

```{r}
funimagery %>%
ggplot(aes(intervention, kg1)) +
geom_boxplot() +
scale_y_continuous(breaks = seq(55,180,5))
```

Another way to describe the distribution of the data is using a density plot. Density plots look like this:

```{r}
funimagery %>%
ggplot(aes(kg1,, color=intervention)) +
geom_density()
```

The height of the lines shows how many people, relatively speaking, had the baseline weight
shown on the x axis. So we can see that the vast majority of patients had baseline weight between 70 and 110kg.

We're not going to practice this technique here, but if you want to learn how to make a density plot, you could refer back to our [stage 1 teaching materials here](https://www.andywills.info/rminr/corr.html).

---

The point to make here is that we can learn a lot by just describing the differences between groups — either with descriptive _statistics_ like means and standard deviations or --- often better --- by visualising the data.

funimagery %>%
group_by(intervention) %>%
summarise(quibble2(weight_lost_end_trt))

funimagery %>% group_by(intervention) %>% summarise(range(weight_lost_end_trt))

quibble2 <- function(x, q = c(0.25, 0.5, 0.75)) {
tibble("{{ x }}\_quantile" := q, "{{ x }}" := quantile(x, q))
}
