---
title: 'Session 1:Title TODO'
author: 'Ben Whalley, Paul Sharpe, Sonja Heintz'
# date: "April 2021"
bibliography: [references.bib]
csl: apa.csl
#biblio-style: apa6
link-citations: yes
output:
  webex::html_clean
---

```{r, include=F, echo=F}
source('_first_chunk.R')
```

# Overview

Some martial arts have a concept called 'Mushin'. A literal translation of this is 'mind without mind'. It denotes a state of mind achieved when free from thoughts of anger, fear, or ego, during combat or in everyday life. To achieve mushin takes **repeated practice** and complete familiarity with the technique required to act, so that technical details can fade into the background. 

We think there is an analogy to learning R here:

- If you are anxious, stressed or avoidant you will be distracted and find it harder to learn
- Getting confident with the basics makes more complex techniques possible 

This session is about building skills and mastering core techniques. We will use these skills throughout the course.
If some parts are already familiar to you, that's fine.  If it is all new, be sure to complete all the exercises/pracice problems.


![TODO: replace with feelgood video](images/video_placeholder.png)

`r hide('Video script')`
In this session we cover:

- Loading data from files
- Using simple techniques to answer research questions with data
- Saving intermediate steps using variables

`r unhide()`

<!-- - Provide stereotyped examples of the sorts of students positive/negative traits which relate to the theme of session - make it all more concrete -->
<!-- Use quotes from previous students illustrating? -->

# Principles/ideas 

- Using data to answer questions
- Precision and literal-mindedness of R
- Paths and directories

# R techniques covered

- [Storing data in variables](#variables)
- [Passing data to functions using the pipe `%>%`](#pipe)
- [Loading data from elsewhere](#loadingdata)
- [The **Files** pane](#filespane)
- [Uploading data files](#upload)
- [Selecting rows with `filter()`](#filter)
- [Sorting data using `arrange()`](#arrange)
- [Combining `filter()` with `arrange()`](#filterarrange)
- [Summarising data using `summarise()`](#summarise)
- [Grouping data with `group_by()`](#groupby)
- [R comments](#comments)

<!-- Activity: -->

<!-- ???  set up the teaching as a kind of treasure hunt where students have to find use data to answer questions, gather -->
<!-- clues and spell out a word? Alternatively, just ask them to make *LOTs* of different plots using the techniques above, not -->
<!-- just one: -->

# Storing data in variables {#variables}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- In R, a **variable** is the name for a *container* which *stores data*.
- We make variables using the **assignment operator**, which looks like this: `<-`.
- Values on the right hand side of `<-` are stored in the variable on the left hand side.
- Variables that you create are stored in the `Global Environment`. You can see these using the **Environment** pane.

### Code examples

```{r}
# calculate 40 + 2 and assign the result to a variable
meaning_of_life <- 40 + 2

# print the variable we created to the console window
meaning_of_life
```

<!-- START OF VIDEO -->
`r hide('Video script')`
As we work, it's useful to be able to save the results of the code we write. 

As one example, we might have a dataset with multiple columns, each holding participants' answers 
to an individual questionnaire item. We might want to calculate a new column —— maybe an average of each 
person's scores on all of the questions —— and keep track of this so we can use it in later calculations. 

Alternatively, we might want to save the result of a specific calculation and use it later on.

To do this we can create a **variable**. 

A variable is just a container to store data in. To make variables we use the assignment operator, which looks like this `<-`

That is, like an arrow that points to the left. This is a reminder that the results of the calculation on the right hand
side will be assigned (stored) in the variable on the left hand side.

The code in this chunk runs the calculation on the right hand side of the assignment operator, `40 + 2`, and assigns the
result to a new variable named `meaningoflife`. The output of the chunk is `42`, the value of `meaningoflife`.

Give your variables short names which describe the data they contain. Use the underscore `_` if you need to use more
than one word e.g. `meaning_of_life`.

You might wonder *where* these variables get saved. In most cases, variables you create are stored in what's called the
`Global Environment`. You can see them in the **Environment** pane in RStudio. Double-clicking on any variable there
will show you what is stored inside the container.
`r unhide()`
<!-- END OF VIDEO -->

:::{.exercise}
**Exercise 1**

1. Open `session-2.rmd` using the **Files** pane. This is the workbook you will be using in this session.
1. Run the first chunk in the workbook.

The output should look like this:

![Results of creating `meaningoflife` variable](images/life.png)

Your **Environment** pane should look like this:

![Environment pane after creating variable](images/environment1.png)
:::

:::{.exercise}
**Exercise 2**

1. Create a level 3 markdown heading named "Exercise 2" in your workbook
1. Create a new chunk beneath the heading
1. Assign the results of the calculation `2 * 35` to the variable `seventy`
1. Run the chunk

Your **Environment** should now look like this:

![Environment pane after creating new variable](images/environment2.png)

:::

:::{.exercise}

**Exercise 3**

1. Create a level 3 markdown heading named "Exercise 3" in your workbook
1. Use R to calculate your age in the year 2051.
1. Save the result in a variable _with a descriptive name_.
:::


# Using pipes (`%>%`) to pass data {#pipe}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- We pass data from one piece of code to another using **the pipe** function
- The pip looks like this: `%>%`
- The keyboard shortcut to write a pipe is `Cmd` + `Shift` + `M`
- A **pipeline** is a sequence of functions joined by pipes
- Store the results of a pipeline in a variable using assignment (`<-`)


### Code examples

```{r}
# pipe mtcars into head()
mtcars %>% head()

# store first few rows of mtcars
mtcars_head <- mtcars %>%
  head()
```


<!-- START OF VIDEO -->
`r hide('Video script')`
Sometimes we need to link together multiple steps in our analysis.

For example, if we're working with a big dataset we might want to select only some of the columns, and then filter out some of the rows of data, and the finally calculate descriptive statistics.

We could do this by creating lots of variables, each one saving the results at each intermediate step. This can get confusing, though.

Instead we can use what's known as a 'pipe' — it's another way to link together multiple instructions.

The pipe sends data from one piece of code to another.

The pipe looks like this `%>%`.  

In session 1, you used this code to "pipe" the `mtcars` dataset into `head()`, which shows just the first few rows:

```{r}
mtcars %>% head()
```

You can think of your data as flowing along lengths of pipe, joined by functions which do things to the data, step by
step, until the result you want plops out at the end.

Each `%>%` should be read as the word "then", e.g. "pipe `mtcars` data, *then* `head()` it".

The `>` in the pipe function reminds you of the direction in which your data is flowing (it only works left to right).

It's important to know that the pipe *doesn't store the results* of these steps. 

Sometimes that's OK. In our first example we just wanted to look at the first few rows of the `mtcars` data. 

But, you will usually want to save the result of a pipeline in a new variable.  
For example, if we wanted to save the first few rows of the `mtcars` data  to a *new* variable we would write:

```{r}
mtcars_head <- mtcars %>% head()
```

Here we combine *assignment* with a *pipeline*.

The result of the pipeline (a `data.frame` containing the first few rows of `mtcars`) is saved to a
new variable called `mtcars_head`.

You can explore your variables using the **Environment** pane. A `data.frame` will have an icon that looks like a
spreadsheet. If you [click on the icon], the `data.frame` is displayed in a new tab in the **Source** pane.

This tab shows you the same information as printing the `data.frame`, such as the number of rows and columns, but it
also provides tools for exploring the data interactively.

* The arrows next to the column names allow you to arrange the rows in ascending or descending order based on the column
values.
* The `Filter` button allows you to specify a value for one or more columns to filter out non-matching rows. For
example, we could display just cars with 4 gears. Click the button again to turn off the filter.
`r unhide()`

<!-- END OF VIDEO -->

:::{.exercise}
**Exercise 4**

1. Create a level 3 markdown heading named "Exercise 4" in your workbook. (You should be used to doing this for every exercise by now, so we won't remind you again.)  <!-- TODO is this true enough yet? -->
1. Create a new code chunk beneath this heading
1. Load the `tidyverse` library
1. Pipe the `mpg` `data.frame` into `head()` and assign the results to a variable called `mpg_head`
1. Use the **Environment** pane to open `mpg_head`
In 1999, a 6-cylinder, manual transmission, Audio A4 could cover `r fitb('18')` miles per gallon when driven in the
city.
:::

# Loading data from elsewhere {#loadingdata}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- Often we want to load data into R, rather than use built-in datasets.
- The preferred format for data files in R is comma-separated value (CSV)
- A CSV file usually includes column names in the first row; each row after that contains the data
- CSV files should always end in `'.csv'` (this is the file extension)
- CSV data can be read using the `read_csv()` function.
- You can load CSV data from an internet address (URL) or a file uploaded to the server.


<!-- THERE IS NO CODE EXAMPLE FOR THIS VIDEO -->

## Loading data

`r hide('Video script')`

In a lot of these workshops we use datasets that are built-in to R. This is a convenient way to illustrate 
the points we make.

[demo opening glancing some built in data like gapminder, iris, mtcars etc]

Normally, though, you will need to load your own data.

R can read data from two places:

- A URL (web address), if the data file is available on the internet somewhere
- A file on computer that R is running on

The link below is a URL (web address) for a file containing data about US police shootings.

- [https://benwhalley.github.io/lifesavR/data/shootings.csv](https://benwhalley.github.io/lifesavR/data/shootings.csv)


The final part of the url tells us the name of the file: `shootings.csv`

The final 3 (sometimes 4) letters of the filename is called the file extension.

Here the file *extension* is `.csv`, which stands for 'comma separated values' or CSV.

CSV is a common data type. Most data-oriented programmes (e.g. Excel or Open Office or SPSS) can read and write `.csv` files, so it's a good choice for storing and sharing data.

If you click on the link [click link in vid] you'll see the first line is a list of column names separated by commas. 

The remaining lines contain rows of data matching the column headings. For example, the value of the `arms_category` column in row 1 is `Guns`.

The `read_csv()` function reads a CSV file, and converts it to a `data.frame`, which is the format we use in R. 

We can use `read_csv()` to load data from either a file, or over the internet, which is shown in the next video.

`r unhide()`


## Reading CSV files from the internet

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- `read_csv('http://...')` can load data from a URL.
- It converts the data to a `data.frame`.
- You must assign the loaded data to a variable, which you should give a descriptive name.
- Use the **Environment** pane to view data you load using `read_csv()`.


### Code examples

```{r}
# load data from a URL and assign it to a variable, called shootings
shootings <- read_csv('https://benwhalley.github.io/lifesavR/data/shootings.csv')

# display the stored data
shootings
```

<!-- TODO can you make this the default button text everywhere (was shorter above) -->
`r hide('Show full video transcript and code')`
CSV files are a common format to store and share data. As shown in the previous video, the first line of a CSV file
defines the column names, and the remaining lines are rows of data.

The `read_csv()` function reads a CSV file, and converts it to a `data.frame`, which is the format we use in R.  We can load data either from a file, or over the internet.

In this example, I'm reading a CSV directly over the Internet and storing the resulting `data.frame` in the
variable `shootings`.

The URL (the link to the CSV file) needs to be in quotes (single or double quotes both work).

<!-- TODO should we adopt doubles everywhere? they have the advantage of not wrapping or hanging the console across line breaks -->
```{r}
shootings <- read_csv("https://benwhalley.github.io/lifesavR/data/shootings.csv")
```

Because we made a new variable, the result is stored in the Environment, and we can double-click it to have a look at the data.

An alternative (and recommended) way is to simply type the name of the variable and run the line:

```{r}
shootings
```

Or you can select the name of the variable in your code, and hit ctrl+Enter:
[in this section of the video I select the word "shootings" and press ctrl+Enter. This has the same effect.]
```{r, eval=F}
shootings <- read_csv("https://benwhalley.github.io/lifesavR/data/shootings.csv")
```

`r unhide()`

:::{.exercise}
**Exercise 5**

1. Create a new chunk.
1. Read the data stored at <https://benwhalley.github.io/lifesavR/data/shootings.csv>
1. View it using the **Environment** pane.
1. View it using `glimpse()`.
:::








## Using data from your computer {#upload}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- Before using your own data you must upload it to the server.
- Data can be uploaded using the **Files** pane.
- Always upload data to the same location as your R code  (or rmd file).
- For data you upload, give `read_csv()` the path to the CSV file.
- Assign the data you load to a variable. Give this a descriptive name.
- Use the **Environment** pane to view data.


### Code examples

```{r, eval=F}
# load a csv file uploaded to the server
shootings <- read_csv('shootings.csv')

# note - this will only work if the file called shootings.csv is uploaded to the server
# and in the same place as your .rmd file
```


`r hide('Show full video transcript and code')`
The `Upload` button in the **Files** pane lets you upload a file from your computer to R Studio. R Studio uses file
extensions to guess what the file contains. A file extension is a sequence of characters, starting with a `.` at the end
of a file name.

- `.csv` - CSV file
- `.rmd` - R Markdown file

Make sure that any file you upload has the correct file extension.

We'll upload `shootings.csv` from the previous exercise.

1. Click the `Upload` button.
1. Ensure the `Target directory` is where you want the uploaded file to appear. For this module it should read `~/lifesavr`. The `~` (pronounced "tilde") means your `Home` directory on the R Studio server. The `/lifesavr` means the folder named `lifesaver` in `Home`.
1. Click the `Choose file` button and select the file you want to upload. After you select a file, its name appears next to the button.
1. Click the `**OK**` button.

The file should appear in the **Files** pane in your `lifesavr` folder.
`r unhide()`

:::{.exercise}
**Exercise 6**

1. Use your web browser to download <https://benwhalley.github.io/lifesavR/data/shootings.csv> to your computer
1. Upload `shootings.csv` to the server
1. Create a new code chunk in your workbook
1. Read `shootings.csv` into a variable with a descriptive name.

In which city was the earliest recorded shooting? `r fitb('Shelton')`
:::

# Selecting rows with `filter()` {#filter}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- The `filter()` function selects *rows* from a dataset where values in that row match criteria we set.
- The simplest filter uses `==` (two equality symbols) to test if values in the row match exactly.
- When matching text data upper/lower case, spaces and punctuation all matter.
- We can use other filters like `<` or `>` for numeric data.
- We can combine multiple filters.


### Code examples

```{r}
# load gapminder dataset
library(gapminder)

# filter rows where country is equal to the word "Kenya" 
# (double-equality symbols require an exact match)
gapminder %>% 
  filter(country == "Kenya")

# matches rows where year is greater than 2000
gapminder %>% 
  filter(year > 2000)

# matches rows with low life expectancy
gapminder %>% 
  filter(lifeExp < 35)

# combines multiple filters
gapminder::gapminder %>% 
  filter(country=="Kenya") %>% 
  filter(year > 2000) %>% 
  filter(lifeExp < 55)
```


<!-- TODO LABEL -->
`r hide('Video script')`

TODO ADD PREAMBLE/EXPLANATION OF AIM OF VIDEO

The following chunk filters the `gapminder` dataset to include only rows where the `country` column equals "Kenya".

<!-- TODO NOT  SURE IF BEST TO LOAD GAPMINDER LIBRARY OR NOT... PERHAPS NOT. EITHER WAY BE CONSOSTENT AND 
EITHER USE GAPMINDER OR GAPMINDER::GAPMINDER -->

```{r}
library(gapminder)
gapminder %>% filter(country == "Kenya")
```


The `==` is called an "operator". It compares values from the column on the left hand side with the value specified on
the right hand side. The value *must* match the column type. The value `"Kenya"` was in quotes because the country
column is a factor.

The "greater than" operator `>` filters numeric data.

```{r}
gapminder %>% filter(year > 2000)
```

This chunk filters rows where `year` is greater than 2000.

The opposite of the `>` operator is the `<` operator. This filters numeric columns which are *less than* a value.

Combined filters

```{r}
gapminder::gapminder %>% 
  filter(country=="Kenya") %>% 
  filter(year > 2000)
```


TODO - ADD AN EXAMPLE HERE OF SOMETHING WITH A SPACE OR INCORRECT CAPITALISATION NOT MATCHING


`r unhide()`

:::{.exercise}
**Exercise 7**

Filter `gapminder` to show countries with a population greater than 100 million.

Your results should look like this:

```{r, echo=FALSE}
gapminder %>% filter(pop > 100000000)
```

:::

:::{.exercise}

**Exercise 8**

Show countries with a population greater than 100 million and life expectancy greater than 70.

The results should look like this:

```{r, echo=FALSE}
gapminder %>%
  filter(pop > 100000000) %>%
  filter(lifeExp > 70)
```

:::

# Sorting data using `arrange()` {#arrange}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- The `arrange()` function sorts rows in a dataset.
- Give `arrange()` a single column name to sort data in ascending order.
- To sort in descending order, put a `-` before the column name.
- Use commas between column names to sort by more than once column at once


### Code examples

```{r}
# sort by carat in ascending order
diamonds %>%
  arrange(carat) %>%
  head(3)

# sort by carat in descending order (spot the minus sign in front of 'caret')
diamonds %>%
  arrange(-carat) %>%
  head(3)

# sort by price (descending) within carat (ascending)
diamonds %>%
  arrange(carat, -price)
```

`r hide('Video script')`

TODO ADD PREAMBLE / RATIONALE FOR THIS
SORTING IS A WAY TO GET MIN/MAX and INSPECT IN A TABLE

Sort by carat in ascending order

```{r}
diamonds %>%
  arrange(carat) %>%
  head(3)
```

Sort by carat in descending order

```{r}
diamonds %>%
  arrange(-carat) %>%
  head(3)
```

Sort by price (descending) within carat (ascending)

```{r}
diamonds %>%
  arrange(carat, -price)
```
`r unhide()`

:::{.exercise}
**Exercise 9**

1. Sort the `diamonds` dataset by ascending price.
1. Show only the first five rows of the results.

Your answer should look like this:

```{r, echo=FALSE}
diamonds %>%
  arrange(price) %>%
  head(5)
```

:::


:::{.exercise}

**Exercise 10**

How big is the largest diamond in the `diamonds` dataset? `r fitb('5.01')` carats.

What was the cut of the three largest diamonds in that dataset? `r fitb('Fair')`.

:::


# Combine `filter()` with `arrange()` {#filterarrange}

![TODO: replace with video](images/video_placeholder.png)

### Video summary

- Pipelines combine functions to answer specific questions
- A good example of this is combining `filter()` and `arrange()`


### Code examples

```{r}
# show which years Kenyans had their lowest life expectancy
gapminder::gapminder %>%
  filter(country == "Kenya") %>% 
  arrange(lifeExp) %>% 
  head(6)

# show which year Kenyans with their life expectancy (just add '-')
gapminder::gapminder %>% 
  filter(country == "Kenya") %>% 
  arrange(-lifeExp) %>%
  head(6)
```

`r hide('Video script')`
What was the year Kenyans had the lowest life exp:

```{r}
gapminder::gapminder %>%
  filter(country == "Kenya") %>% 
  arrange(lifeExp) %>% 
  head(6)
```

What was the highest year? All that changes is the minus sign (reverse sorting)

```{r}
gapminder::gapminder %>% 
  filter(country == "Kenya") %>% 
  arrange(-lifeExp) %>%
  head(6)
```

`r unhide()`

:::{.exercise}

**Exercise 11**

1. Sort all Asian countries in the `gapminder` dataset in ascending population order.
1. Show only the first 10 rows.

Your results should look like this:

```{r, echo=FALSE}
gapminder::gapminder %>%
  filter(continent == "Asia") %>% 
  arrange(pop) %>% 
  head(10)
```

**Exercise 12**

Use `filter()`, `arrange()` and `head()` to answer the following questions:

The European country with the highest life expectancy is `r fitb('Iceland')`.

The European country with the fifth largest population was recorded in which year? `r fitb('2007')`.
:::



PAUL - I'M WORRIED WEAKWR STUDENTS WON'T GET THIS FAR.

PERHAPS WE SHOULD PUSH SUMMARISE INTO SESSION 3? I CERTAINLY THINK THIS IS TRUE FOR GROUP-BY

WE CAN MOTIVATE THIS BY FINDING LONG FORM DATA WE WANT TO SUMMARISE THEN RUN A T TEST ON.






# Summarising data using `summarise()` {#summarise}

![TODO: replace with video](images/video_placeholder.png)

Video summary:

- Often you have lots of data and need to make summaries of it, e.g. to calculate the average of a column.
- The `summarise()` function takes many rows and uses a **function** to convert those into fewer rows.
- Common summary functions are those which calculate descriptive statistics, like `mean()`, `median()`, and `sd()`, which is short for standard deviation.
- The output of `summarise()` is a `data.frame` which can be stored in a variable.

```{r}
# use function mean() to summarise mpg column
# the result is a data.frame with the a single column named 'mean_mpg'
mtcars %>%
  summarise(mean_mpg = mean(mpg))

# if you omit the column name, the summarised column is named after summary function used to create it
# this produces column names which can be awkward to process later in a pipeline
mtcars %>%
  summarise(mean(mpg))

# median mpg
mtcars %>%
  summarise(median_mpg = median(mpg))

# standard deviation
mtcars %>%
  summarise(sd_mpg = sd(mpg))

# summarise two columns at once (functions are separated with a comma)
# store the resulting data.frame in a variable
mtcars_summary <- mtcars %>%
  summarise(M = mean(mpg), SD = sd(mpg))
```

`r hide('Video script')`
Show

```{r}
mtcars %>% summarise(average_mpg = mean(mpg))
```

and also

```{r}
mtcars %>% summarise(mean(mpg))
```

emphasising that the former is better

Also show replacing with median, sd etc.

This is where we fist encounter the need to give things R-legal names so explain about spaces and special characters
Emphasise everything should be lower case with underscores.

Then show calculating two new cols at once:

mtcars %>% summarise(M = mean(mpg), SD = sd(mpg))

Point out the comma between the two in commentary
`r unhide()`

:::{.exercise}
**Exercise 13**

1. Copy the code above into your workbook.
1. Amend the code to calculate the median weight.
1. Note that `mtcars` stores weight in units of 1000 lbs.

The median car weight is `r fitb('3.325')` pounds.

**Exercise 14**

1. Amend the code to calculate the mean and standard deviation of weight.

To the nearest pound, the mean car weight is `r fitb('3217')` pounds, and the standard deviation is `r fitb('978')`
pounds.
:::

## Using `filter()` and `summarise()` together

![TODO: replace with video](images/video_placeholder.png)

Video summary:

- We often want to filter a dataset before summarising.
- We can do this by creating a pipeline with `filter()` and `summarise()`.

```{r}
# calculate the mean for cars with manual transmission (am == 1)
mtcars %>% 
  filter(am == 1) %>% 
  summarise(mean_mpg = mean(mpg))
```

`r hide('Video script')`

Calculate the mean for cars with manual transmission (am == 1)

```{r}
mtcars %>% 
  filter(am == 1) %>% 
  summarise(mean_mpg = mean(mpg))
```

`r unhide()`

:::{.exercise}
**Exercise 15**

```{r, echo=FALSE, eval=FALSE}
mtcars %>% 
  filter(am == 0) %>% 
  summarise(sd_mpg = sd(mpg))
```
Use `filter()` and `summarise()` to calculate the standard deviation of cars with automatic transmission.

Cars with automatic transmission have a standard deviation (to two decimal places) of `r fitb('3.83')` miles per gallon.
:::

# Grouping data with `group_by()` {#groupby}

![TODO: replace with video](images/video_placeholder.png)

Video summary:

- Our data may have categorical or 'grouping' variables (e.g. gender, or country).
- We often want to create summaries for each group.
- We could use `filter()` and `summary()` once for each group, but the `group_by()` function does this for all groups.
- Adding `group_by()` to a pipeline runs the subsequent steps *once for each group*.
- Be careful only to group by categorical variables.

<!-- TODO: Having made the point about factors, is it misleading that cyl and am are dbl rather than fct in he following? -->
<!-- C02 is one of the few built-in datasets with > 1 factor. Types are now in session 3, so I'm not sure which is better here, introducing factor() or introducing a different dataset. -->

```{r}
# boxplot of C02 uptake grouped by grass type
CO2 %>%
  ggplot(aes(Type, uptake)) + 
  geom_boxplot()

# table of C02 uptake grouped by grass type
CO2 %>%
  group_by(Type) %>% 
  summarise(average_uptake = mean(uptake))

# group by two factors at once: grass type and experimental treatment
CO2 %>%
  group_by(Type, Treatment) %>%
  summarise(mean(uptake))
```

```{r, echo=FALSE, eval=FALSE}
# boxplot grouped by number of cylinders
mtcars %>% 
  ggplot(aes(factor(cyl), mpg)) + 
  geom_boxplot()

# table
mtcars %>% 
  group_by(cyl) %>% 
  summarise(average_mpg = mean(mpg))

# group by two variables at once
mtcars %>%
  group_by(cyl, am) %>%
  summarise(mean(mpg))
```

`r hide('Video script')`
In this video we'll use a dataset about plants rather than cars. Plants photosynthesise by combining sunlight with carbon dioxide to make sugars. The CO2 dataset carbon dioxide update for two species of grass. The species is a factor.

We might make a plot like this:

```{r}
CO2 %>%
  ggplot(aes(Type, uptake)) + 
  geom_boxplot()
```

But what if we want these numbers in a table (or to report in our report)? We can 
do that using group_by and summarise...

```{r}
CO2 %>%
  group_by(Type) %>% 
  summarise(average_uptake = mean(uptake))
```

Another factor in this dataset is an experimental treatment -- whether the grasses were `chilled` or `nonchilled`. We
can also group by two factors at once and get a row for each combination:

```{r}
CO2 %>%
  group_by(Type, Treatment) %>%
  summarise(mean(uptake))
```
`r unhide()`

:::{.exercise}
**Exercise 16**

`chickwts` contains data for the weights of chicks (in grams) fed on different diets.

```{r}
glimpse(chickwts)
```

Calculate the mean and standard deviation chick weights for each type of feed.

```{r, echo=FALSE, eval=FALSE}
chickwts %>%
  group_by(feed) %>%
  summarise(mean(weight), sd(weight))
```
The mean weight of chicks fed on linseed was (to 2 decimal places) `r fitb('218.75')`g.

The standard deviation of chicks fed on sunflower was (to 2 decimal places) `r fitb('48.84')`g.
:::

# Check your knowledge

Write an answer to each of these questions in the `Check your knowledge` section of your workbook. The answers will be
revealed in Session 3.

1. What is the `<-` symbol called and what does it do?
1. What is the `%>%` symbol called and what does it do?
1. Which function is used to load data and what are the two places that data can be loaded from?
1. How would you select rows from a `data.frame` where values in a numeric column are between 10 and 20?
1. How would you sort a `data.frame` by a numeric column in descending order? <!-- TODO: too easy? -->
1. How would you select rows from a column which match a word, and then sort those rows in ascending order by a numeric column?
1. Which functions would you use to calculate the mean of a numeric column?
1. Which other two functions are commonly used to calculate descriptive statistics?
1. How could you calculate the mean for one level of a factor?
1. How would you calculate the mean for all levels of a factor?

# Extension exercises

## Extension exercise 1

```{r, eval=FALSE, echo=FALSE}
gapminder::gapminder %>% 
  filter(year == 1952) %>% 
  arrange(-lifeExp) %>% 
  head(1)
```

The country with the highest life expectancy in 1952 was `r fitb('Norway')`. (Hint: use `arrange()`, `filter()` and
`head()` with the `gapminder` dataset.)

## Extension exercise 2

```{r, echo=FALSE, eval=FALSE}
gapminder::gapminder %>% 
  group_by(continent) %>%
  filter(year == '1987') %>%
  summarise(average_gdp = mean(gdpPercap)) %>% 
  arrange(-average_gdp)
```

The continent with the highest mean per capita GDP in 1987 was `r fitb('Oceania')`. (Hint: use `filter()`, `arrange()`,
`group_by()`, and `summarise()`.)

## Extension exercise 3

Make a boxplot showing life expectancy by continent for years greater than 1999. (Hint: use `filter()`, `ggplot()` and `geom_boxplot()`.)

The plot should look like this:

```{r, echo=FALSE}
gapminder::gapminder %>% 
  filter(year > 1999) %>% 
  ggplot(aes(continent, lifeExp)) + 
  geom_boxplot()
```

## Extension exercise 4

The last two exercises are like the end of level "boss characters" in a computer game. To beat them, you need to select
and combine skills you've learnt so far.

```{r, echo=FALSE, eval=FALSE}
gapminder %>%
  filter(continent == 'Africa') %>%
  filter(year < '2000') %>%
  arrange(-pop, lifeExp)
```

Before the year 2000, the African country with the largest population and the lowest life expectancy was
`r fitb('Nigeria')`.

## Extension exercise 5

Make a table which shows the average life expectancy for each continent, sorted from highest to lowest. It should look like this:

```{r, echo=FALSE}
gapminder %>%
  group_by(continent) %>%
  summarise(life_expectancy = mean(lifeExp)) %>%
  arrange(-life_expectancy)
```

<!-- TODO: Ben: need to chat more to finish this and other "fix script" tasks -->

# Broken script to fix

Start a NEW R session and make this code work:
 
```{r, eval=F}
liibrary(todyverse)

# make a density plot of of life expectacy with different color lines for each continent
gapminder %>% 
  ggplote(aes("lifeExp", colr = "Continent"))  geom_density()

# select only years after 1990
gapminder %>% 
  filter(year > 1990)

ggplot(aes(year, lifeExp, color=continent)) + 
  geom_jitter()
```

NOTE - we will know all the errors they will see so can provide hints for each of them

```{r}
# correct version 
library(tidyverse)

# make a density plot of of life expectacy with different color lines for each continent
gapminder %>% 
  ggplot(aes(lifeExp, color = continent))  + 
  geom_density()

# select only years after 1990
gapminder::gapminder %>% 
  filter(year > 1990) %>%
  ggplot(aes(year, lifeExp, color=continent)) + 
  geom_jitter()
```
