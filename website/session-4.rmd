---
title: 'Describing patterns, answering questions'
author: 'Ben Whalley, Paul Sharpe, Sonja Heintz'
# date: "April 2021"
bibliography: [references.bib]
csl: apa.csl
#biblio-style: apa6
link-citations: yes
output:
  webex::html_clean:
    highlight: tango
---

```{r, include=F, echo=F}
source('_first_chunk.R')
source('tabbed-rmd.R')
```



```{html, child="bs-tab-fix.html"}
```


```{css, child="video.css"}
```


![](images/spotpatterns.png)


# Overview


An important task for quantitative researchers is to **answer questions using data**.
We can often divide this activity into:

- Describing patterns in the data
- Quantifying how *sure* we are about those patterns

This session is all about describing and visualising patterns in the data to answer research questions.



### Techniques covered

- [Central tendency and spread](#centralspread)
- [The *frequency* of responses](#responsefrequency)
- [Relationships](#relationships)

```{r, echo=F}
video_data <- list(identifier = "describe-overview", showcode = F,
yt_id="DNla39W33II")
# makermds(video_data)
```

```{r child = '_content/_video_tabs.rmd'}
```



# Central tendency and spread{#centralspread}

`r video("4mn_XxnSjUQ")`
`r make_tabs('describe-centrantend')`

:::{.tab-content}

:::{#describe-centrantend-summary .tab-pane .active}

- the *central tendency* of the data describes the "middle" of a set of values
- the mean and median are the most common measures
- measures of *spread* or distribution of the data show where most of the values fall (i.e. what range of values are most likely)
- common measures are the standard deviation or interquartile range
- we have already seen how to calculate these statistics using `summarise()` and `group_by()`

:::

:::{#describe-centrantend-code .tab-pane .fade}
```{r}
# this is a recap of earlier material

# calculate an average
# typical weight at baseline in the FIT trial
funimagery %>%
  summarise(mean(kg1))

# boxplots show the interquartile range (IQR) as the height of the box.
# The IQR is the range which includes 50% of the data points
funimagery %>%
  ggplot(aes(intervention, kg1)) +
  geom_boxplot() +
  scale_y_continuous(n.breaks = 10) # this extra line just adds more marks on the y-axis
```
:::


:::{#describe-centrantend-transcript .tab-pane .fade}


If we have a single continous variable — that is, one stored in a numeric column in R —  then can describe a few things about it, including:

1. the *central tendency* of the data: e.g. mean, median ([see here for refresher](https://www.graduatetutor.com/statistics-tutor/measures-of-central-tendency-mean-median-mode/))
2. the *spread* or distribution of the data: e.g. the standard deviation or interquartile range ([see refresher here](https://www.statisticshowto.com/probability-and-statistics/standard-deviation/#SDD))

It's important to remember that even simple descriptive statistics like the mean or standard deviation enable us to *answer research questions* — you don't always need fancy statistics! For example, if we consider the `funimagery` data describing the RCT of functional imagery training, we could ask:

- *"what was the typical weight of participants at baseline?"* or
- *"what was the **range** in which most participants' weight fell?"*

In part, you have already seen how techniques like `group_by()` and `summarise()`, or graphs like boxplots, can help calculate and present these *descriptive statistics*.


```{r}
# (this is a recap of earlier material)
# typical weight at baseline
funimagery %>%
  summarise(mean(kg1))


# a boxplot showing the IQR as the box. The IQR includes 50% of participants
# so, we can see 50% of participants weighed between 80 and 100kg at baseline
funimagery %>%
  ggplot(aes(intervention, kg1)) +
  geom_boxplot() +
  scale_y_continuous(n.breaks = 10) # this extra line just adds more marks on the y-axis
```




## Describing *differences*

The previous table and boxplot showed patients' weights at the start of the study.

There is also a variable in this dataset called `weight_lost_end_trt`,
which shows how much weight people lost between starting and completing FIT or MI.
In a previous session we made a boxplot like this:

```{r, echo=F}
funimagery %>%
  ggplot(aes(intervention, weight_lost_end_trt)) +
  geom_boxplot()
```

However, in clinical trials, it's important to measure participants for longer periods to judge whether the effect of a treatment is sustained.

Interventions for obesity and overweight can be successful, but patients may later regain weight [@hall2018maintenance]. And estimating how long weight loss is sustained for is important because it changes the long term prognosis of patients, and so how cost-effective an intervention is.

The `funimagery` data come from a study which followed people for 6 months after completing treatment (12 months after joining the study). The `kg1` column records weights at baseline, and the`kg3` columns
records observations made at the end of follow-up


This means we can calculate weight loss from baseline to follow-up (not just the end of treatment, which has already been done for us).

To do this we need to create a *new column* in our dataset. Let's call this `weight_lost_end_followup`.

To calculate this new column we need to subtract weight at baseline (`kg1`) from weight at the end of follow-up (`kg3`).

In R, we can do this with the `mutate` function:

```{r, eval=T}
# use `mutate` to create a NEW COLUMN of data
# this code shows the result just below the code chunk
funimagery %>%
  mutate(weight_lost_end_followup = kg3 - kg1)
```


:::{.direction}

- run the code above and show students the result
- point out that this has not been stored anywhere — just displayed in the RStudio GUI, below the code chunk

:::


What mutate does is to make a copy of our dataset, but with a new column in. That
is, it always gives us back a new dataset.

We almost always want to STORE this new copy of the dataset so we
can use the new column that was created.
To do this we assign the result of mutate `funimagery` dataset by *assigning*
the result of `mutate())` to a new variable (the 'container' type of variable).

The assignment operator is the left hand arrow, `<-`:

```{r}
funimagery.edited <- funimagery %>%
  mutate(weight_lost_end_followup = kg3 - kg1)
```


:::{.direction}

- show how a new variable has been created in the ***Environment*** window

:::


So the code above:

- takes the `funimagery` data and pipes it to the `mutate()` function, which
- adds a new column, called `weight_lost_end_followup`
- this new column is made by subtracting `kg1` (baseline) from `kg3` (end of followup); it then
- stores this new copy of the dataset (with the extra column) in a new *variable* called `funimagery.edited`:


We can then use this new variable, `funimagery.edited`, to do more work, like making a boxplot:

```{r}
# boxploot of weight lost at end of follow-up using new column
funimagery.edited %>%
  ggplot(aes(intervention, weight_lost_end_followup)) +
  geom_boxplot()
```

If anything, it looks like the difference between groups is even BIGGER after follow-up than it was at the end of treatment, which is very promising for FIT.

:::

:::





:::{#ex1 .exercise}

<!-- REMEMBER TO UPDATE THE WORKBOOK IF YOU TOUCH THIS !!! -->

**Exercise 1**

1. Open `session-4.rmd` using the **Files** pane. This is the workbook you will be using in this session.
1. Use `group_by()` and `summarise()` with the built-in `iris` dataset to calculate the mean `Sepal.Width` for each `Species` of flower.
1. Make a boxplot that shows the sepal width for each species of flower.

These are the correct numbers to check your work against:

```{r, echo=F, include=T}
iris %>%
  group_by(Species) %>%
  summarise(`Mean sepal width` =  sprintf("%.1f", mean(Sepal.Width) )) %>%
  pander()


mean(mtcars$mpg)
```

Your plot should look like this:

```{r, echo=F, include=T}
iris %>%
  ggplot(aes(Species, Sepal.Width)) +
  geom_boxplot()
```


```{r, echo=F, include=F}
aesmcqq <- c("aes(Species, Sepal.Width))", "aes('Species', 'Sepal.Width')", "aes((species, sepal.width))", answer="aes(Species, Sepal.Width)")
```


The `aes` part of your ggplot code should be: `r mcq(aesmcqq)`

:::



:::{.exercise}
**Exercise 2**

In the video you saw how to use `mutate()` to create a new column which is the difference between values in two other columns.

1. Using the `funimagery` dataset, create a column representing weight lost between end of treatment and at the end of
followup.
1. Make a boxplot of these data.

Your plot should look like this:

```{r, echo=FALSE}
funimagery.edited <- funimagery %>%
  mutate(weight_lost_trt_followup = kg3 - kg2)

funimagery.edited %>%
  ggplot(aes(intervention, weight_lost_trt_followup)) +
  geom_boxplot()
```

:::


# The *frequency* of responses{#responsefrequency}


```{r, echo=F}
video_data <- list(identifier = "describe-frequency", yt_id = "XB-b454apj4")
# makermds(video_data)
```

```{r child = '_content/_video_tabs.rmd'}
```


:::{.exercise}
**Exercise 3**

```{r, echo=F, include=F}
funcounts <- funimagery %>% count(intervention, gender)
```

1. Use the `funimagery` data and `count()` to count how many participants there were in each intervention group.
1. How many men were in the FIT group? `r mcq(c(12,14,answer=funcounts$n[4], 18, 33, 28))`

<!-- funimagery %>% count(intervention, gender) -->

:::




# Relationships {#relationships}

```{r, echo=F}
video_data <- list(identifier = "describe-relationships", yt_id="PGV-MZlCoOc")
# makermds(video_data)
```

```{r child = '_content/_video_tabs.rmd'}
```



:::{.exercise}
**Exercise 4**

1. Load the `corrr` package (use the `library()` function).
1. Use the `fuel` dataset from the `psydata` package, to calculate the correlation between `power` and `engine_size`.

:::


:::{.exercise}
**Exercise 5**

It's helpful to get a feel for what the data would look like for different correlation coefficients.
<http://guessthecorrelation.com> is a game designed to help with this.

- The game shows you a scatterplot; your job is to guess the correlation coefficient.
- Try and get to about 30 points without losing any lives!  If you like you can get competitive and play a two-player game!

- Play now: <http://guessthecorrelation.com>



:::


# Check your knowledge

Write an answer to each of these questions in the `Check your knowledge` section of your workbook. The answers will be
revealed in Session 5.



- What functions in R describe the central tendency of a variable?
- What type of column can we use with `mean`?
- How might you describe patterns in a categorical variable?
- What function did we use to create a new column in the `funinmagery` dataset?
- In the `funimagery` data, how much weight did FIT participants lose AFTER the end of treatment?
- What type of plot describes the relationship between two variables?
- What function do we use to make a plot that shows a relationship between two variables in `ggplot`?



# Extension exercises


```{r, child="_content/extension-exercises-premable.rmd"}
```


:::{.exercise}
**Extension exercise 1**

Correlations require that there is a *linear relationship* between the two variables. That is, the pattern in a
scatterplot should be fairly close to a straight line.

1. Plot pairs of variables from the `fuel` dataset.
2. Which pairs would be NOT be suitable for calculating a correlation?

`r hide()`

Engine size and MPG would be one example. There is a curved relationship between them:

```{r, echo=F, warning=F, message=F}
fuel %>% ggplot(aes(engine_size, mpg)) + geom_point() + geom_smooth(method=lm, formula=y~poly(x, 2), se=F)
```

The problem here is that a single straight line isn't appropriate for the data: The slope is
much less steep at the right hand side of the plot, but the correlation doesn't capture that, so
it's not a good statistic to describe the pattern we see here.



`r unhide()`

:::




# References
